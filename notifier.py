import csv
import os
import smtplib
from datetime import datetime, timezone
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText


def send_email_digest(new_tweets: list[dict], config: dict):
    email_cfg = config["notification"]["email"]
    if not email_cfg.get("enabled"):
        return

    if not new_tweets:
        return

    html = _build_html(new_tweets)

    msg = MIMEMultipart("alternative")
    msg["Subject"] = (
        f"Indus Feedback Digest — {datetime.now(timezone.utc).strftime('%b %d, %Y %H:%M')} UTC"
    )
    msg["From"] = email_cfg["sender_email"]
    msg["To"] = email_cfg["recipient_email"]
    msg.attach(MIMEText(html, "html"))

    with smtplib.SMTP(email_cfg["smtp_server"], email_cfg["smtp_port"]) as server:
        server.starttls()
        server.login(email_cfg["sender_email"], email_cfg["sender_password"])
        server.send_message(msg)


_BUCKET_LABELS = {
    "product_feedback": "Product Feedback",
    "feature_request": "Feature Requests",
    "general_feedback": "General Feedback",
}

_BUCKET_COLORS = {
    "product_feedback": "#f97316",
    "feature_request": "#7856ff",
    "general_feedback": "#1d9bf0",
}


def _build_html(tweets: list[dict]) -> str:
    buckets: dict[str, list[dict]] = {}
    for t in tweets:
        b = t.get("bucket", "other")
        buckets.setdefault(b, []).append(t)

    pf_count = len(buckets.get("product_feedback", []))
    fr_count = len(buckets.get("feature_request", []))
    gf_count = len(buckets.get("general_feedback", []))

    rows_html = ""
    for bucket_key in ["product_feedback", "feature_request", "general_feedback"]:
        items = buckets.get(bucket_key, [])
        if not items:
            continue
        label = _BUCKET_LABELS.get(bucket_key, bucket_key)
        color = _BUCKET_COLORS.get(bucket_key, "#536471")
        rows_html += (
            f'<h2 style="color:{color};font-size:18px;margin-top:28px;'
            f'border-left:4px solid {color};padding-left:12px;">'
            f'{label} ({len(items)})</h2>'
        )
        for t in items:
            rows_html += _tweet_card(t, color)

    return f"""\
<html>
<body style="font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
             max-width:620px;margin:0 auto;padding:20px;color:#1a1a1a;">
  <h1 style="color:#1d9bf0;font-size:22px;border-bottom:2px solid #1d9bf0;padding-bottom:10px;">
    Indus Feedback Digest
  </h1>
  <p style="color:#536471;font-size:14px;">
    Found <strong>{len(tweets)}</strong> new tweet(s) —
    <span style="color:#f97316;font-weight:bold;">{pf_count} product feedback</span>,
    <span style="color:#7856ff;font-weight:bold;">{fr_count} feature requests</span>,
    <span style="color:#1d9bf0;font-weight:bold;">{gf_count} general feedback</span>
  </p>
  {rows_html}
  <p style="color:#536471;font-size:12px;margin-top:32px;border-top:1px solid #e1e8ed;padding-top:12px;">
    Generated by Indus Feedback Collector
  </p>
</body>
</html>"""


def _tweet_card(t: dict, accent: str = "#1d9bf0") -> str:
    return f"""\
<div style="border:1px solid #e1e8ed;border-left:3px solid {accent};border-radius:12px;padding:16px;margin-bottom:12px;background:#f7f9fa;">
  <div style="font-weight:bold;color:#0f1419;">
    {_esc(t['author_name'])}
    <span style="color:#536471;font-weight:normal;">@{_esc(t['author_handle'])}</span>
  </div>
  <p style="margin:8px 0;line-height:1.5;">{_esc(t['text'])}</p>
  <div style="color:#536471;font-size:13px;">
    Likes {t.get('likes', 0)} &nbsp; RT {t.get('retweets', 0)} &nbsp; Replies {t.get('replies', 0)}
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <a href="{t['tweet_url']}" style="color:#1d9bf0;text-decoration:none;">View on X</a>
  </div>
</div>"""


def _esc(text: str) -> str:
    return text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")


_CSV_FIELDS = [
    "tweet_id",
    "author_name",
    "author_handle",
    "text",
    "tweet_url",
    "source_type",
    "source_detail",
    "parent_text",
    "parent_url",
    "likes",
    "retweets",
    "replies",
    "tweet_created_at",
    "collected_at",
]


def export_to_csv(new_tweets: list[dict], csv_path: str):
    if not new_tweets:
        return

    os.makedirs(os.path.dirname(csv_path), exist_ok=True)
    file_exists = os.path.exists(csv_path)

    with open(csv_path, "a", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=_CSV_FIELDS)
        if not file_exists:
            writer.writeheader()
        for tweet in new_tweets:
            writer.writerow({k: tweet.get(k, "") for k in _CSV_FIELDS})
